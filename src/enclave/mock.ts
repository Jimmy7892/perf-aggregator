/**
 * Mock TEE Enclave Service for Development
 * 
 * SECURITY WARNING: This is a development-only implementation.
 * In production, replace with actual TEE enclave (AWS Nitro, Intel SGX, etc.)
 * 
 * This mock simulates enclave behavior:
 * - Decrypts credentials using a development private key
 * - Computes deterministic signed aggregates  
 * - Provides mock attestation quotes
 * - Demonstrates proper secret handling patterns
 */

import { createHash, randomBytes } from 'crypto';
import { BaseEnclaveService } from './interface.js';
import type {
  EncryptedPayload,
  DecryptedCredentials,
  SignedAggregates,
  AttestationQuote
} from '../types/index.js';
import { signEd25519Base64, verifyEd25519 } from '../libs/crypto.js';
import { canonicalize } from '../libs/canonical.js';
import { ValidationUtils } from '../utils/validation.js';

interface SessionData {
  sessionId: string;
  credentials: DecryptedCredentials;
  createdAt: Date;
  aggregates?: SignedAggregates;
  merkleRoot?: string;
}

export class MockEnclaveService extends BaseEnclaveService {
  // Development keys - NEVER use in production
  protected readonly enclavePrivateKey: string;
  protected readonly enclavePublicKey: string;
  private readonly x25519PrivateKey: Buffer;
  
  // In-memory session storage (simulates enclave sealed storage)
  private sessions = new Map<string, SessionData>();
  
  constructor() {
    super();
    
    // Generate deterministic development keys for testing
    const seed = Buffer.from('dev-enclave-seed-change-in-production', 'utf8');
    const hash = createHash('sha256').update(seed).digest();
    
    // Mock ED25519 keys for signing
    this.enclavePrivateKey = hash.toString('base64');
    this.enclavePublicKey = createHash('sha256').update(this.enclavePrivateKey).digest('base64');
    
    // Mock X25519 private key for ECDH
    this.x25519PrivateKey = hash.subarray(0, 32);
    
    console.log('üîí Mock Enclave Service initialized (DEV ONLY)');
    console.log('üìã Enclave Public Key:', this.enclavePublicKey.substring(0, 16) + '...');
  }

  async getAttestationQuote(): Promise<AttestationQuote> {
    // Mock attestation quote - in production, this would be generated by TEE hardware
    const mockQuote = Buffer.from(JSON.stringify({
      version: '1.0',
      timestamp: Date.now(),
      enclave_measurement: 'mock-measurement-' + createHash('sha256').update('mock-enclave').digest('hex'),
      flags: ['DEBUG'], // Indicates this is a development enclave
    })).toString('base64');
    
    return {
      quote: mockQuote,
      enclave_pubkey: this.enclavePublicKey,
      image_hash: 'mock-' + createHash('sha256').update('dev-enclave-image').digest('hex')
    };
  }

  async submitKey(sessionId: string, payload: EncryptedPayload): Promise<{ success: boolean; error?: string }> {
    try {
      console.log(`üîê Decrypting credentials for session ${sessionId} (DEV MOCK)`);
      
      // Validate input format
      const validation = ValidationUtils.validateEncryptedPayload(payload);
      if (!validation.valid) {
        return { success: false, error: validation.errors.join(', ') };
      }

      // Decrypt credentials (mock implementation)
      const credentials = await this.decryptCredentials(payload);
      
      // Validate decrypted credentials
      if (!credentials.exchange || !credentials.apiKey || !credentials.apiSecret) {
        this.secureZeroCredentials(credentials);
        return { success: false, error: 'Invalid credentials format' };
      }

      // Store in enclave memory (simulated)
      this.sessions.set(sessionId, {
        sessionId,
        credentials,
        createdAt: new Date()
      });

      console.log(`‚úÖ Credentials stored for session ${sessionId}, exchange: ${credentials.exchange}`);
      return { success: true };

    } catch (error) {
      console.error('‚ùå Failed to decrypt credentials:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Decryption failed' 
      };
    }
  }

  async requestAggregates(sessionId: string): Promise<{
    aggregates_signed: SignedAggregates;
    merkle_root: string;
  }> {
    const session = this.sessions.get(sessionId);
    if (!session) {
      throw new Error(`Session ${sessionId} not found in enclave`);
    }

    // Check if aggregates already computed
    if (session.aggregates && session.merkleRoot) {
      return {
        aggregates_signed: session.aggregates,
        merkle_root: session.merkleRoot
      };
    }

    console.log(`üìä Computing aggregates for session ${sessionId} (DEV MOCK)`);

    // Mock aggregate computation - in production, this would use real trading data
    const mockAggregates = this.computeMockAggregates(session.credentials);
    
    // Sign the aggregates
    const canonical = canonicalize(mockAggregates);
    const signature = signEd25519Base64(canonical, this.enclavePrivateKey);
    
    const signedAggregates: SignedAggregates = {
      signature,
      payload: mockAggregates
    };

    // Generate mock merkle root
    const merkleRoot = createHash('sha256')
      .update(sessionId + canonical + Date.now())
      .digest('hex');

    // Cache results
    session.aggregates = signedAggregates;
    session.merkleRoot = merkleRoot;

    console.log(`‚úÖ Aggregates computed and signed for session ${sessionId}`);

    return {
      aggregates_signed: signedAggregates,
      merkle_root: merkleRoot
    };
  }

  async revoke(sessionId: string): Promise<void> {
    const session = this.sessions.get(sessionId);
    if (session) {
      // Securely zero credentials in memory
      this.secureZeroCredentials(session.credentials);
      
      // Remove from enclave storage
      this.sessions.delete(sessionId);
      
      console.log(`üóëÔ∏è Session ${sessionId} revoked and purged from enclave`);
    }
  }

  /**
   * Mock credential decryption using X25519 ECDH + AES-GCM
   * In production, this would use actual TEE crypto libraries
   */
  private async decryptCredentials(payload: EncryptedPayload): Promise<DecryptedCredentials> {
    // Mock decryption - in reality this would:
    // 1. Perform X25519 ECDH with ephemeral_pub and enclave private key
    // 2. Derive AES-GCM key using HKDF
    // 3. Decrypt ciphertext using derived key, nonce, and verify tag
    
    // For development, return mock decrypted data
    const mockCredentials: DecryptedCredentials = {
      exchange: 'binance',
      apiKey: 'mock-api-key-' + randomBytes(8).toString('hex'),
      apiSecret: 'mock-api-secret-' + randomBytes(16).toString('hex'),
      sandbox: true,
      symbols: ['BTC/USDT', 'ETH/USDT']
    };

    return mockCredentials;
  }

  /**
   * Generate deterministic mock aggregates for testing
   */
  private computeMockAggregates(credentials: DecryptedCredentials) {
    // Create deterministic but realistic-looking aggregates
    const seed = createHash('sha256').update(credentials.apiKey + credentials.exchange).digest();
    const random = (index: number) => (seed[index % seed.length] / 255);

    const baseReturn = (random(0) - 0.5) * 20; // ¬±10% range
    const volatility = random(1) * 0.3 + 0.1; // 0.1-0.4 range
    
    return {
      pnl: Math.round((baseReturn * 1000 + (random(2) - 0.5) * 200) * 100) / 100,
      sharpe: Math.round((baseReturn / volatility) * 100) / 100,
      volume: Math.round(random(3) * 100000 * 100) / 100,
      trades: Math.floor(random(4) * 500) + 10,
      from: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
      to: new Date().toISOString()
    };
  }

  /**
   * Securely zero credentials in memory
   */
  private secureZeroCredentials(credentials: DecryptedCredentials): void {
    this.secureZeroString(credentials.apiKey);
    this.secureZeroString(credentials.apiSecret);
    credentials.apiKey = '';
    credentials.apiSecret = '';
  }


  /**
   * Get development session info (for testing only)
   */
  getSessionInfo(sessionId: string) {
    const session = this.sessions.get(sessionId);
    if (!session) return null;
    
    return {
      sessionId: session.sessionId,
      exchange: session.credentials.exchange,
      createdAt: session.createdAt,
      hasAggregates: !!session.aggregates
    };
  }
}